// Copyright (c) 2022 The Orbit Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "FileWriter.h"
#include "WinMdUtils.h"

#include "OrbitBase/Logging.h"
#include "OrbitBase/TaskGroup.h"

// Cppwin32 expects an instance of a 'settings_type' object.
namespace cppwin32 {
settings_type settings;
}

namespace orbit_windows_api_shim {

namespace {
constexpr const char* kWindowsApiFunctionDefinition =
   R"(struct WindowsApiFunction {
  const char* function_key = nullptr;
  const char* name_space = nullptr;
  uint32_t function_id = 0;
};

)";

constexpr const char* kOrbitHeader =
    R"(// Copyright (c) 2022 The Orbit Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

)";

constexpr const char* kNamespaceDispatcherHeader = R"(

// NOTE: This file was generated by Orbit's WindowsApiShimGenerator.

namespace orbit_windows_api_shim {

  bool FindOrbitShimFunctionInfo(const char* function_key,
                                OrbitShimFunctionInfo& out_function_info) {
    std::optional<std::string> name_space = WindowsApiHelper::Get().GetNamespaceFromFunctionKey(function_key);
    if (!name_space.has_value()) return false;
    
    typedef bool (*FunctionType)(const char* function_key, OrbitShimFunctionInfo& out_function_info);

    static const std::unordered_map<std::string, FunctionType> dispatcher = {{
)";

constexpr const char* kNamespaceDispatcherFooter = R"(
      }};

      const auto function_it = dispatcher.find(name_space.value());
      if (function_it == dispatcher.end()) return false;
      return function_it->second(function_key, out_function_info);
    }
}  // namespace orbit_windows_api_shim
)";

void write_orbit_instrumentation(cppwin32::writer& w, method_signature const& signature,
                                 std::optional<uint32_t> function_id) {
  if (function_id.has_value()) {
    w.write("        orbit_windows_api_shim::ApiFunctionScope orbit_scope(__FUNCTION__, %);\n",
            function_id.value());
  } else {
    ORBIT_ERROR("No function id was provided");
  }

  if (signature.params().size()) {
    for (auto&& [param, param_signature] : signature.params()) {
      w.write("        ORBIT_TRACK_PARAM(%);\n", param.Name());
    }
  }
}

void write_orbit_instrumentation_ret(cppwin32::writer& w, method_signature const& signature) {
  if (!signature.return_signature()) {
    return;
  }

  w.write("ORBIT_TRACK_RET(%);", signature.return_param_name());
}

void write_class_method_with_orbit_instrumentation(
    cppwin32::writer& w, method_signature const& method_signature, const WinMdHelper& win_md_helper,
    const FunctionIdGenerator& function_id_generator) {
  std::string function_key = win_md_helper.GetFunctionKeyFromMethodDef(method_signature.method());
  std::optional<uint32_t> function_id = function_id_generator.GetFunctionIdFromKey(function_key);

  if (!function_id.has_value()) {
    ORBIT_LOG("Warning: Could not find function id for \"%s\"", function_key);
  }

  w.write("    % __stdcall ORBIT_IMPL_%(%) noexcept {\n%\n%g_api_table.%(%);\n%%}",
          cppwin32::bind<cppwin32::write_method_return>(method_signature), function_key,
          cppwin32::bind<cppwin32::write_method_params>(method_signature),
          cppwin32::bind<write_orbit_instrumentation>(method_signature, function_id),
          cppwin32::bind<cppwin32::write_consume_return_type>(method_signature),
          function_key,
          cppwin32::bind<cppwin32::write_method_args>(method_signature),
          cppwin32::bind<write_orbit_instrumentation_ret>(method_signature),
          cppwin32::bind<cppwin32::write_consume_return_statement>(method_signature));
}

void write_class_impl(cppwin32::writer& w, TypeDef const& type, const WinMdHelper& win_md_helper,
                      const FunctionIdGenerator& function_id_generator) {
  auto abi_guard = w.push_abi_types(true);
  auto ns_guard = w.push_full_namespace(true);

  w.write("extern \"C\"\n{\n");

  for (auto&& method : type.MethodList()) {
    if (!IsX64(method)) continue;
    method_signature signature{method};
    write_class_method_with_orbit_instrumentation(w, signature, win_md_helper,
                                                  function_id_generator);
    w.write("\n");
  }
  w.write("}\n\n");
}

void write_class_api_table(cppwin32::writer& w, TypeDef const& type,
                           const WinMdHelper& win_md_helper) {
  auto const format = R"xyz(    % (__stdcall *%)(%) noexcept;
)xyz";

  if (!IsWindMdListEmpty(type.MethodList())) {
    w.write("\nstruct ApiTable {\n");
    for (auto&& method : type.MethodList()) {
      if (!IsX64(method)) continue;

      if (method.Flags().Access() == winmd::reader::MemberAccess::Public) {
        method_signature signature{method};
        w.write(format, cppwin32::bind<cppwin32::write_abi_return>(signature.return_signature()),
                win_md_helper.GetFunctionKeyFromMethodDef(method),
                cppwin32::bind<cppwin32::write_abi_params>(signature));
      }
    }
    w.write("};\nextern ApiTable g_api_table;\n\n");
  }
}

void write_class_abi(cppwin32::writer& w, TypeDef const& type, const WinMdHelper& win_md_helper) {
  auto abi_guard = w.push_abi_types(true);
  auto ns_guard = w.push_full_namespace(true);

  if (!IsWindMdListEmpty(type.MethodList())) {
    w.write("extern \"C\"\n{");

    for (const winmd::reader::MethodDef& method : type.MethodList()) {
      if (method.Flags().Access() == winmd::reader::MemberAccess::Public && IsX64(method)) {
        method_signature signature{method};
        std::string function_key = win_md_helper.GetFunctionKeyFromMethodDef(method);
        w.write("    % __stdcall ORBIT_IMPL_%(%) noexcept;\n",
                cppwin32::bind<cppwin32::write_abi_return>(signature.return_signature()),
                function_key, cppwin32::bind<cppwin32::write_abi_params>(signature));
      }
    }
    w.write("}\n");
    write_class_api_table(w, type, win_md_helper);
    w.write("\n");
  }

  w.write(
      "  bool GetOrbitShimFunctionInfo(const char* function_key, OrbitShimFunctionInfo& "
      "out_function_info);\n");
}

void WriteNamespaceGetOrbitShimFunctionInfo(cppwin32::writer& w, TypeDef const& type,
                                            const WinMdHelper& win_md_helper) {
  w.write(
      "\nbool GetOrbitShimFunctionInfo(const char* function_key, OrbitShimFunctionInfo& "
      "out_function_info)\n{\n");

  if (!IsWindMdListEmpty(type.MethodList())) {
    w.write(
        "  static std::unordered_map<std::string, std::function<void(OrbitShimFunctionInfo&)>> "
        "function_dispatcher = {\n");

    for (auto&& method : type.MethodList()) {
      if (!IsX64(method)) continue;
      w.write("    ORBIT_DISPATCH_ENTRY(%),\n", win_md_helper.GetFunctionKeyFromMethodDef(method));
    }

    w.write("  };\n\n");
    w.write("  auto it = function_dispatcher.find(function_key);\n");
    w.write("  if(it != function_dispatcher.end()) {\n");
    w.write("    it->second(out_function_info);\n    return true;\n  }\n\n");
  }

  w.write(
      "  ORBIT_SHIM_ERROR(\"Could not find function \"%s\" in current namespace\", "
      "function_key);\n");
  w.write("  return false;\n}\n\n");
}

struct FunctionInfo {
  std::string name;
  std::string module;
  std::string key;
  std::string name_space;
};

}  // namespace

FileWriter::FileWriter(std::vector<std::filesystem::path> input, std::filesystem::path output_dir) {
  std::filesystem::create_directories(output_dir / "win32/impl");

  std::vector<std::string> input_files;
  cppwin32::settings.output_folder = output_dir.string();
  for (const auto& path : input) {
    input_files.emplace_back(path.string());
  }
  cache_ = std::make_unique<winmd::reader::cache>(input_files);
  win32_database_ = FindDatabaseFromName(*cache_, "Windows.Win32.winmd");
  win32_metadata_helper_ = std::make_unique<WinMdHelper>(*win32_database_);
}

void FileWriter::WriteCodeFiles() {
  static bool lean_test_output = true;

  if (lean_test_output) {
    std::set<std::string_view> lean_namespace_names = {"Windows.Win32.Foundation"};
    win_md_cache_ = std::make_unique<WinMdCache>(cache_.get(), lean_namespace_names);
  } else {
    win_md_cache_ = std::make_unique<WinMdCache>(cache_.get());
  }

  {
    orbit_base::TaskGroup task_group;

    // Writing the manifest assigns id to functions. This is executed before the async tasks below
    // as they depend on the function ids from the manifest generation.
    function_id_generator_ = WriteManifestHeader();

    for (auto& entry : win_md_cache_->GetCacheEntries()) {
      task_group.AddTask([&, &ns = entry.namespace_name, &members = *entry.namespace_members] {
        cppwin32::write_namespace_0_h(ns, members);
        cppwin32::write_namespace_1_h(ns, members);
        WriteNamespaceHeader(entry);
        WriteNamespaceCpp(entry);
      });
    }

    task_group.AddTask([this] { WriteComplexStructsHeader(); });
    task_group.AddTask([this] { WriteComplexInterfaceHeader(); });
    task_group.AddTask([this] { WriteNamespaceDispatchCpp(); });
  }

  WriteCmakeFile();
}

FunctionIdGenerator FileWriter::WriteManifestHeader() {
  //*win_md_cache_, win32_database_
  cppwin32::writer w;

  w.write("#pragma once\n\n");
  w.write("#include <array>\n");
  w.write("#include <stdint.h>\n\n");
  w.write(kWindowsApiFunctionDefinition);

  std::map<const MethodDef, std::string> method_def_to_namespace;
  FunctionIdGenerator function_id_generator;

  for (const auto& entry : win_md_cache_->GetCacheEntries()) {
    for (const TypeDef& c : entry.namespace_members->classes) {
      for (const MethodDef& method : c.MethodList()) {
        if (method.Flags().Access() == winmd::reader::MemberAccess::Public) {
          method_def_to_namespace.emplace(method, std::string(entry.namespace_name));
          // check emplace took place
        }
      }
    }
  }

  {
    std::map<std::string, FunctionInfo> function_key_to_info;
    uint32_t impl_count = 0;
    std::string log;
    const winmd::reader::database* db = win32_database_;
    for (const ImplMap& impl_map : db->get_table<ImplMap>()) {
      std::string function_name(impl_map.ImportName());
      ModuleRef module_ref = db->get_table<ModuleRef>()[impl_map.ImportScope().index()];
      std::string module_name = absl::AsciiStrToLower(module_ref.Name());

      const MethodDef& method_def = db->get_table<MethodDef>()[impl_map.MemberForwarded().index()];
      std::string function_key = win32_metadata_helper_->GetFunctionKeyFromMethodDef(method_def);

      // Hack, we need to figure out how to iterate on functions of filtered namespaces.
      if (method_def_to_namespace.count(method_def) == 0) {
        continue;
      }

      if (function_key_to_info.find(function_key) != function_key_to_info.end()) {
        log += function_key + "\n";
      }

      FunctionInfo& function_info = function_key_to_info[function_key];
      // Check insertion took place.
      function_info.name = function_name;
      function_info.module = module_name;
      function_info.key = function_key;
      function_info.name_space = method_def_to_namespace.at(method_def);
      ++impl_count;
    }

    w.write("// DO NOT MODIFY Manifest.h, it is generated when building WindowsApiShim.\n");
    w.write("// num namespaces: %\n", win_md_cache_->GetCacheEntries().size());
    w.write("// num modules: %\n", db->get_table<ModuleRef>().size());
    w.write("// num functions: %\n", function_key_to_info.size());
    w.write("// num impl: %\n", impl_count);
    w.write("/*\n%\n*/\n", log);
    w.write("constexpr std::array<const WindowsApiFunction, %> kWindowsApiFunctions = {{\n",
            function_key_to_info.size());
    for (const auto& [key, function_info] : function_key_to_info) {
      uint32_t function_id = function_id_generator.GetOrCreateFunctionIdFromKey(function_info.key);
      w.write("  {\"%\", \"%\", %},\n", function_info.key, function_info.name_space, function_id);
    }
    w.write("}};\n\n");
  }

  w.flush_to_file(cppwin32::settings.output_folder + "win32/manifest.h");
  return function_id_generator;
}

void FileWriter::WriteCmakeFile() {
  cppwin32::writer w;
  w.write("# DO NOT MODIFY. This file is generated by the WindowsApiShimGenerator project.\n\n");
  w.write(absl::StrFormat("# %s\n\n", GetCurrentTimeFormatted()));

  std::vector<std::string> public_headers = {"base.h", "NamespaceDispatcher.h", "manifest.h"};
  std::vector<std::string> private_source = {"complex_interfaces.h", "complex_structs.h",
                                             "NamespaceDispatcher.cpp"};
  for (const auto& entry : win_md_cache_->GetCacheEntries()) {
    public_headers.push_back(absl::StrFormat("%s.h", entry.namespace_name));
    private_source.push_back(absl::StrFormat("%s.0.h", entry.namespace_name));
    private_source.push_back(absl::StrFormat("%s.1.h", entry.namespace_name));
    private_source.push_back(absl::StrFormat("%s.cpp", entry.namespace_name));
  }

  // Public headers.
  w.write("set(WINDOWS_API_SHIM_HEADERS\n");
  for (auto& header : public_headers) {
    w.write(absl::StrFormat("    ${WINDOWS_API_SHIM_GENERATED_DIR}/win32/%s\n", header));
  }
  w.write(")\n");

  // Private sources.
  w.write("set(WINDOWS_API_SHIM_SOURCES\n");
  for (auto& source : private_source) {
    w.write(absl::StrFormat("    ${WINDOWS_API_SHIM_GENERATED_DIR}/win32/impl/%s\n", source));
  }
  w.write(")\n");

  w.flush_to_file(cppwin32::settings.output_folder + "WindowsApiShim.cmake");
}

void FileWriter::WriteNamespaceDispatchCpp() {
  cppwin32::writer w;
  w.write(kOrbitHeader);
  w.write("#include \"NamespaceDispatcher.h\"");

  // Disable "enumerator value cannot be represented as 'int'
  w.write("\n#pragma warning(push)");
  w.write("\n#pragma warning(disable : 4369)\n");

  // Include all namespace headers.
  for (auto& entry : win_md_cache_->GetCacheEntries()) {
    w.write("#include \"win32/%.h\"\n", entry.namespace_name);
  }

  // Pop warning
  w.write("#pragma warning(pop)\n\n");

  w.write(kNamespaceDispatcherHeader);

  for (auto& entry : win_md_cache_->GetCacheEntries()) {
    if (entry.namespace_members->classes.size() == 0) continue;
    std::string shim_namespace = absl::StrFormat("%s", entry.namespace_name);
    std::string cpp_namespace = absl::StrReplaceAll(shim_namespace, {{".", "::"}});
    w.write("        {\"%\", &win32::%::GetOrbitShimFunctionInfo},\n", shim_namespace,
            cpp_namespace);
  }

  w.write(kNamespaceDispatcherFooter);
  w.flush_to_file(cppwin32::settings.output_folder + "win32/impl/NamespaceDispatcher.cpp");
}

void FileWriter::WriteComplexStructsHeader() {
  cppwin32::writer w;

  write_preamble(w);
  write_open_file_guard(w, "complex_structs");

  for (auto&& depends : w.depends) {
    w.write_depends(depends.first, '0');
  }

  cppwin32::type_dependency_graph graph;
  for (auto& entry : win_md_cache_->GetCacheEntries()) {
    for (const auto& s : entry.namespace_members->structs) {
      if (cppwin32::is_x64_struct(s)) graph.add_struct(s);
    }
  }

  graph.walk_graph([&](TypeDef const& type) {
    if (!is_nested(type)) {
      auto guard = wrap_type_namespace(w, type.TypeNamespace());
      write_struct(w, type);
    }
  });

  write_close_file_guard(w);
  w.flush_to_file(cppwin32::settings.output_folder + "win32/impl/complex_structs.h");
}

void FileWriter::WriteComplexInterfaceHeader() {
  cppwin32::writer w;

  w.write(kOrbitHeader);
  write_preamble(w);
  write_open_file_guard(w, "complex_interfaces");

  for (auto& depends : w.depends) {
    w.write_depends(depends.first, '1');
  }
  // Workaround for https://github.com/microsoft/cppwin32/issues/2
  for (auto& extern_depends : w.extern_depends) {
    auto guard = wrap_type_namespace(w, extern_depends.first);
    w.write_each<cppwin32::write_extern_forward>(extern_depends.second);
  }

  cppwin32::type_dependency_graph graph;
  for (const auto& entry : win_md_cache_->GetCacheEntries()) {
    for (auto& _interface : entry.namespace_members->interfaces) {
      graph.add_interface(_interface);
    }
  }

  graph.walk_graph([&](TypeDef const& type) {
    if (!is_nested(type)) {
      auto guard = wrap_type_namespace(w, type.TypeNamespace());
      write_interface(w, type);
    }
  });

  write_close_file_guard(w);

  w.flush_to_file(cppwin32::settings.output_folder + "win32/impl/complex_interfaces.h");
}

void FileWriter::WriteNamespaceHeader(const WinMdCache::Entry& cache_entry) {
  cppwin32::writer w;
  w.type_namespace = cache_entry.namespace_name;

  w.write(kOrbitHeader);
  write_preamble(w);
  write_open_file_guard(w, cache_entry.namespace_name);

  // Includes.
  w.write_root_include("base");
  w.write("\n#include \"win32/impl/complex_structs.h\"\n");
  w.write("#include \"win32/impl/complex_interfaces.h\"\n");
  w.write("#include \"WindowsApiShimUtils.h\"\n");
  w.write("#include \"WindowsApiCallManager.h\"\n");
  w.write_depends(w.type_namespace, '0');
  w.write("\n");

  // Workaround for https://github.com/microsoft/cppwin32/issues/2
  for (auto&& extern_depends : w.extern_depends) {
    auto guard = wrap_type_namespace(w, extern_depends.first);
    w.write_each<cppwin32::write_extern_forward>(extern_depends.second);
  }

  if (!cache_entry.namespace_members->classes.empty()) {
    auto wrap = wrap_type_namespace(w, cache_entry.namespace_name);
    w.write_each<write_class_abi>(cache_entry.namespace_members->classes, *win32_metadata_helper_);
  }

  write_close_file_guard(w);
  w.save_header();
}

void FileWriter::WriteNamespaceCpp(const WinMdCache::Entry& cache_entry) {
  cppwin32::writer w;
  w.type_namespace = cache_entry.namespace_name;

  w.write(kOrbitHeader);
  write_preamble(w);

  w.write("\n#pragma warning(push)");
  w.write("\n#pragma warning(disable : 4369)\n");
  w.write_depends(w.type_namespace);
  w.write_depends(w.type_namespace, '1');
  w.write("#pragma warning(pop)\n\n");

  w.write_depends("manifest");
  w.write("\n#include <functional>\n");
  w.write("\n#include <unordered_map>\n");
  w.write("\n");
  // Workaround for https://github.com/microsoft/cppwin32/issues/2
  for (auto&& extern_depends : w.extern_depends) {
    auto guard = wrap_type_namespace(w, extern_depends.first);
    w.write_each<cppwin32::write_extern_forward>(extern_depends.second);
  }

  {
    auto wrap = wrap_type_namespace(w, cache_entry.namespace_name);

    if (HasMethods(cache_entry.namespace_members->classes)) {
      w.write("ApiTable g_api_table;\n\n");
      w.write("#pragma region abi_methods\n");
      w.write_each<write_class_impl>(cache_entry.namespace_members->classes,
                                     *win32_metadata_helper_,
                                     function_id_generator_);
      w.write("#pragma endregion abi_methods\n\n");
    }

    // HookFunction dispatch.
    w.write_each<WriteNamespaceGetOrbitShimFunctionInfo>(cache_entry.namespace_members->classes,
                                                         *win32_metadata_helper_);
  }

  w.save_cpp();
}

}  // namespace orbit_windows_api_shim
